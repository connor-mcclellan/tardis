name: Update PR Comment Section

on:
  workflow_call:
    inputs:
      section_id:
        required: true
        type: string
        description: 'Unique section identifier (docs, benchmarks, regdata, ruff, orcid, welcome)'
      content:
        required: true
        type: string
        description: 'Content to update in the section'
      pr_number:
        required: true
        type: string
        description: 'PR number'
      collapsible:
        required: false
        type: boolean
        default: false
        description: 'Whether to make content collapsible'
      title:
        required: false
        type: string
        description: 'Section title'
    secrets:
      BOT_TOKEN:
        required: true
        description: 'GitHub token with pull request write permissions'

concurrency:
  group: update-pr-description-${{ inputs.pr_number }}
  cancel-in-progress: true

jobs:
  update-comment:
    runs-on: ubuntu-latest
    steps:
      - name: Update PR Comment
        uses: actions/github-script@v7
        env:
          SECTION_ID: ${{ inputs.section_id }}
          CONTENT: ${{ inputs.content }}
          COLLAPSIBLE: ${{ inputs.collapsible }}
          TITLE: ${{ inputs.title }}
          PR_NUMBER: ${{ inputs.pr_number }}
        with:
          github-token: ${{ secrets.BOT_TOKEN }}
          script: |
            const sectionId = process.env.SECTION_ID;
            const content = process.env.CONTENT;
            const collapsible = process.env.COLLAPSIBLE === 'true';
            const title = process.env.TITLE || sectionId.toUpperCase();
            const prNumber = parseInt(process.env.PR_NUMBER);
            
            // Comment identifier
            const commentMarker = `<!-- TARDIS_${sectionId.toUpperCase()}_COMMENT -->`;
            
            // Format content
            let formattedContent;
            if (collapsible) {
              formattedContent = `## ${title}

            <details>
            <summary>Click to expand</summary>

            ${content}

            </details>`;
            } else {
              formattedContent = `## ${title}

            ${content}`;
            }
            
            const commentBody = `${commentMarker}
            ${formattedContent}`;
            
            // Get existing comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            // Find existing comment with this section
            const existingComment = comments.find(comment => 
              comment.body && comment.body.includes(commentMarker)
            );
            
            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody
              });
            }
